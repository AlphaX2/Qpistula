Änderungen:
-----------

-   Account, MailListModel, MailWrapper sind nun in "libqpistula" zusammengefasst,
    die Import-Anweisungen wurden geändert. (Ordner)

-   Die Methode "check_mails()" (neu "receive_mails()") der Klasse MailAccount 
    nimmt nun einen Ordnernamen entgegen, Standard ist "INBOX", der entsprechende
    Name wird an den abrufenden Thread weitergeleitet. (Account.py)

-   Es wird nun beim starten eine Instanz der Klasse "MailActions" gebildet und 
    dann in der Klasse Qpistula als context gebunden (Qpistula.py)

-   "check_mails()" heißt jetzt "receive_mails()" (Account.py)

-   "loading_done" signal heißt jetzt "receiving_done" (Account.py)

-   Aus dem Account wurden die festen Anmelde-Daten herausgenommen und es wird
    stattdessen ein Pfad zu einem gepickelten Dict übergeben.
    ACHTUNG: In Qpistula.py muss der (vorläufige) Pfad geändert werden
    (Account.py / Qpistula.py)

-   Die MailAccount Klasse wurde umgebaut und soll damit "API-mäßiger" arbeiten,
    sie funktioniert nun folgender Maßen:

    1. Instanz der Klasse erzeugen

    2. Die Methode "receive_mails()" startet den Thread und ruft die letzten
       Mails ab, dabei wird bereits innerhalb der Klasse selbst ein fertiges 
       Mail Model für die Nutzung in Qt/QML genutzt.

    3. Mit dem signal "receiving_done" kann eine Aktualisierung der UI erfolgen,
       mit den Methoden "get_mails_model" kann das fertige Model abgerufen und
       für die Verwendung in Qt/QML genutzt werden. Die Methode 
       "get_first_mail_msg" erlaubt das Abrufen des Textes/Inhalts der ersten
       Mail.

    Entsprechend den Änderungen sind alle Teile die vorher in Qpistula.py waren
    (z.B. Model erzeugen) nun in die Account.py gewandert. Daher wird beim UI 
    Update nur das Model und die erste Nachricht via der Methoden abgerufen und
    als context gesetzt bzw. als Attribut der Klasse (MailActions) gesetzt, wo
    es ja aus QML abgerufen wird (was immer noch übeler Würgaround ist).

    Streitbar wäre natürlich die Frage, ob die Account-Klasse ein fertiges Model
    zurückliefern soll. Weil es dann frei von weiterem Einfluss bliebe. Wenn der
    Teil aber richtig ausgebaut wird, also mit funktionierendem Encoding etc. 
    weiß ich nicht warum er für eine Qt/QML Anwendung kein fertiges (List)Model 
    liefern sollte.
